import React from 'react';
import { CategoricalChartOptions, DataKey, LayoutType, Margin, StackOffsetType } from '../util/types';
import { CategoricalChartState, ExternalMouseEvents } from './types';
import { SyncMethod } from '../synchronisation/types';
/**
 * Simplified version of the MouseEvent so that we don't have to mock the whole thing in tests.
 *
 * This is meant to represent the React.MouseEvent
 * which is a wrapper on top of https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
 */
export interface MousePointer {
    clientX: number;
    clientY: number;
    currentTarget: Pick<HTMLElement, 'getBoundingClientRect' | 'offsetWidth' | 'offsetHeight'>;
}
/**
 * Coordinates relative to the top-left corner of the chart.
 * Also include scale which means that a chart that's scaled will return the same coordinates as a chart that's not scaled.
 */
export interface ChartPointer {
    chartX: number;
    chartY: number;
}
export interface CategoricalChartProps extends Partial<ExternalMouseEvents> {
    accessibilityLayer?: boolean;
    barCategoryGap?: number | string;
    barGap?: number | string;
    barSize?: number | string;
    children?: any;
    className?: string;
    compact?: boolean;
    cx?: number | string;
    cy?: number | string;
    data?: any[];
    dataKey?: DataKey<any>;
    desc?: string;
    endAngle?: number;
    height?: number;
    id?: string;
    innerRadius?: number | string;
    layout?: LayoutType;
    margin?: Margin;
    maxBarSize?: number;
    outerRadius?: number | string;
    reverseStackOrder?: boolean;
    role?: string;
    stackOffset?: StackOffsetType;
    startAngle?: number;
    style?: any;
    syncId?: number | string;
    syncMethod?: SyncMethod;
    tabIndex?: number;
    throttleDelay?: number;
    title?: string;
    width?: number;
}
export declare const generateCategoricalChart: ({ chartName, defaultTooltipEventType, validateTooltipEventTypes, defaultProps, tooltipPayloadSearcher, }: CategoricalChartOptions) => React.ForwardRefExoticComponent<CategoricalChartProps & React.RefAttributes<{
    clipPathId: string;
    container?: HTMLElement;
    render(): React.JSX.Element;
    context: unknown;
    setState<K extends keyof CategoricalChartState>(state: CategoricalChartState | ((prevState: Readonly<CategoricalChartState>, props: Readonly<CategoricalChartProps>) => CategoricalChartState | Pick<CategoricalChartState, K>) | Pick<CategoricalChartState, K>, callback?: () => void): void;
    forceUpdate(callback?: () => void): void;
    readonly props: Readonly<CategoricalChartProps>;
    state: Readonly<CategoricalChartState>;
    refs: {
        [key: string]: React.ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(nextProps: Readonly<CategoricalChartProps>, nextState: Readonly<CategoricalChartState>, nextContext: any): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
    getSnapshotBeforeUpdate?(prevProps: Readonly<CategoricalChartProps>, prevState: Readonly<CategoricalChartState>): any;
    componentDidUpdate?(prevProps: Readonly<CategoricalChartProps>, prevState: Readonly<CategoricalChartState>, snapshot?: any): void;
    componentWillMount?(): void;
    UNSAFE_componentWillMount?(): void;
    componentWillReceiveProps?(nextProps: Readonly<CategoricalChartProps>, nextContext: any): void;
    UNSAFE_componentWillReceiveProps?(nextProps: Readonly<CategoricalChartProps>, nextContext: any): void;
    componentWillUpdate?(nextProps: Readonly<CategoricalChartProps>, nextState: Readonly<CategoricalChartState>, nextContext: any): void;
    UNSAFE_componentWillUpdate?(nextProps: Readonly<CategoricalChartProps>, nextState: Readonly<CategoricalChartState>, nextContext: any): void;
}>>;
