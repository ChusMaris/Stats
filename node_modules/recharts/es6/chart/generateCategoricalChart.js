var _excluded = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import React, { Component, forwardRef } from 'react';
import { LegendPortalContext } from '../context/legendPortalContext';
import { Surface } from '../container/Surface';
import { filterProps, isChildrenEqual, validateWidthHeight } from '../util/ReactUtils';
import { isNullish, uniqueId } from '../util/DataUtils';
import { shallowEqual } from '../util/ShallowEqual';
import { ChartLayoutContextProvider } from '../context/chartLayoutContext';
import { ChartDataContextProvider } from '../context/chartDataContext';
import { ClipPath } from '../container/ClipPath';
import { RechartsStoreProvider } from '../state/RechartsStoreProvider';
import { TooltipPortalContext } from '../context/tooltipPortalContext';
import { RechartsWrapper } from './RechartsWrapper';
import { ReportChartProps } from '../state/ReportChartProps';
import { ReportPolarOptions } from '../state/ReportPolarOptions';
import { ReportMainChartProps } from '../state/ReportMainChartProps';

/**
 * Simplified version of the MouseEvent so that we don't have to mock the whole thing in tests.
 *
 * This is meant to represent the React.MouseEvent
 * which is a wrapper on top of https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
 */

/**
 * Coordinates relative to the top-left corner of the chart.
 * Also include scale which means that a chart that's scaled will return the same coordinates as a chart that's not scaled.
 */

var FULL_WIDTH_AND_HEIGHT = {
  width: '100%',
  height: '100%'
};
var defaultMargin = {
  top: 5,
  right: 5,
  bottom: 5,
  left: 5
};
var defaultLayout = 'horizontal';
export var generateCategoricalChart = _ref => {
  var {
    chartName,
    defaultTooltipEventType = 'axis',
    validateTooltipEventTypes = ['axis'],
    defaultProps = {},
    tooltipPayloadSearcher
  } = _ref;
  class CategoricalChartWrapper extends Component {
    constructor(props) {
      var _props$id;
      super(props);
      this.clipPathId = "".concat((_props$id = props.id) !== null && _props$id !== void 0 ? _props$id : uniqueId('recharts'), "-clip");
      this.state = {};
    }
    static getDerivedStateFromProps(nextProps, prevState) {
      var {
        dataKey,
        data,
        children,
        width,
        height,
        layout,
        stackOffset,
        margin
      } = nextProps;
      if (prevState.updateId === undefined) {
        var defaultState = {};
        return _objectSpread(_objectSpread(_objectSpread({}, defaultState), {}, {
          updateId: 0
        }, {}), {}, {
          prevDataKey: dataKey,
          prevData: data,
          prevWidth: width,
          prevHeight: height,
          prevLayout: layout,
          prevStackOffset: stackOffset,
          prevMargin: margin,
          prevChildren: children
        });
      }
      if (dataKey !== prevState.prevDataKey || data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !shallowEqual(margin, prevState.prevMargin)) {
        var _defaultState = {};
        var updatesToState = {
          // Update the current tooltip data (in case it changes without mouse interaction)
          updateId: prevState.updateId + 1
        };
        var newState = _objectSpread(_objectSpread({}, _defaultState), updatesToState);
        return _objectSpread(_objectSpread({}, newState), {}, {
          prevDataKey: dataKey,
          prevData: data,
          prevWidth: width,
          prevHeight: height,
          prevLayout: layout,
          prevStackOffset: stackOffset,
          prevMargin: margin,
          prevChildren: children
        });
      }
      if (!isChildrenEqual(children, prevState.prevChildren)) {
        // update configuration in children
        var hasGlobalData = !isNullish(data);
        var newUpdateId = hasGlobalData ? prevState.updateId : prevState.updateId + 1;
        return {
          updateId: newUpdateId,
          prevChildren: children
        };
      }
      return null;
    }
    render() {
      if (!validateWidthHeight({
        width: this.props.width,
        height: this.props.height
      })) {
        return null;
      }
      var _this$props = this.props,
        {
          children,
          className,
          width,
          height,
          style,
          compact,
          title,
          desc
        } = _this$props,
        others = _objectWithoutProperties(_this$props, _excluded);
      var attrs = filterProps(others, false);

      // The "compact" mode is mainly used as the panorama within Brush
      if (compact) {
        return /*#__PURE__*/React.createElement(ChartLayoutContextProvider, {
          updateId: this.state.updateId,
          clipPathId: this.clipPathId
        }, /*#__PURE__*/React.createElement(Surface, _extends({}, attrs, {
          width: width,
          height: height,
          title: title,
          desc: desc
        }), /*#__PURE__*/React.createElement(ClipPath, {
          clipPathId: this.clipPathId
        }), children));
      }
      if (this.props.accessibilityLayer) {
        var _this$props$tabIndex, _this$props$role;
        // Set tabIndex to 0 by default (can be overwritten)
        attrs.tabIndex = (_this$props$tabIndex = this.props.tabIndex) !== null && _this$props$tabIndex !== void 0 ? _this$props$tabIndex : 0;
        // Set role to img by default (can be overwritten)
        attrs.role = (_this$props$role = this.props.role) !== null && _this$props$role !== void 0 ? _this$props$role : 'application';
      }
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ChartDataContextProvider, {
        chartData: this.props.data
      }), /*#__PURE__*/React.createElement(TooltipPortalContext.Provider, {
        value: this.state.tooltipPortal
      }, /*#__PURE__*/React.createElement(LegendPortalContext.Provider, {
        value: this.state.legendPortal
      }, /*#__PURE__*/React.createElement(ChartLayoutContextProvider, {
        updateId: this.state.updateId,
        clipPathId: this.clipPathId
      }, /*#__PURE__*/React.createElement(RechartsWrapper, {
        className: className,
        style: style,
        width: width,
        height: height,
        ref: node => {
          this.container = node;
          if (this.state.tooltipPortal == null) {
            this.setState({
              tooltipPortal: node
            });
          }
          if (this.state.legendPortal == null) {
            this.setState({
              legendPortal: node
            });
          }
        },
        onClick: this.props.onClick,
        onMouseLeave: this.props.onMouseLeave,
        onMouseEnter: this.props.onMouseEnter,
        onMouseMove: this.props.onMouseMove,
        onMouseDown: this.props.onMouseDown,
        onMouseUp: this.props.onMouseUp,
        onContextMenu: this.props.onContextMenu,
        onDoubleClick: this.props.onDoubleClick,
        onTouchStart: this.props.onTouchStart,
        onTouchMove: this.props.onTouchMove,
        onTouchEnd: this.props.onTouchEnd
      }, /*#__PURE__*/React.createElement(Surface, _extends({}, attrs, {
        width: width,
        height: height,
        title: title,
        desc: desc,
        style: FULL_WIDTH_AND_HEIGHT
      }), /*#__PURE__*/React.createElement(ClipPath, {
        clipPathId: this.clipPathId
      }), children))))));
    }
  }
  _defineProperty(CategoricalChartWrapper, "displayName", chartName);
  // todo join specific chart propTypes
  _defineProperty(CategoricalChartWrapper, "defaultProps", _objectSpread({
    accessibilityLayer: true,
    layout: defaultLayout,
    stackOffset: 'none',
    barCategoryGap: '10%',
    barGap: 4,
    margin: defaultMargin,
    reverseStackOrder: false,
    syncMethod: 'index'
  }, defaultProps));
  var CategoricalChart = /*#__PURE__*/forwardRef(function CategoricalChart(props, ref) {
    var _props$id2, _ref2, _props$layout, _props$margin, _props$barCategoryGap, _props$stackOffset, _props$syncMethod, _props$startAngle, _props$endAngle;
    var options = {
      chartName,
      defaultTooltipEventType,
      validateTooltipEventTypes,
      tooltipPayloadSearcher,
      eventEmitter: undefined
    };
    var polarOptions;
    var {
      innerRadius = defaultProps.innerRadius,
      outerRadius = defaultProps.outerRadius
    } = props;
    if (defaultProps.startAngle != null) {
      polarOptions = {
        cx: props.cx,
        cy: props.cy,
        startAngle: defaultProps.startAngle,
        endAngle: defaultProps.endAngle,
        innerRadius,
        outerRadius
      };
    }
    return /*#__PURE__*/React.createElement(RechartsStoreProvider, {
      preloadedState: {
        options,
        polarOptions
      },
      reduxStoreName: (_props$id2 = props.id) !== null && _props$id2 !== void 0 ? _props$id2 : chartName
    }, /*#__PURE__*/React.createElement(ReportMainChartProps, {
      width: props.width,
      height: props.height,
      layout: (_ref2 = (_props$layout = props.layout) !== null && _props$layout !== void 0 ? _props$layout : defaultProps.layout) !== null && _ref2 !== void 0 ? _ref2 : defaultLayout,
      margin: (_props$margin = props.margin) !== null && _props$margin !== void 0 ? _props$margin : defaultMargin
    }), /*#__PURE__*/React.createElement(ReportChartProps, {
      accessibilityLayer: props.accessibilityLayer,
      barCategoryGap: (_props$barCategoryGap = props.barCategoryGap) !== null && _props$barCategoryGap !== void 0 ? _props$barCategoryGap : '10%',
      maxBarSize: props.maxBarSize,
      stackOffset: (_props$stackOffset = props.stackOffset) !== null && _props$stackOffset !== void 0 ? _props$stackOffset : 'none',
      barGap: props.barGap,
      barSize: props.barSize,
      syncId: props.syncId,
      syncMethod: (_props$syncMethod = props.syncMethod) !== null && _props$syncMethod !== void 0 ? _props$syncMethod : 'index',
      className: props.className
    }), /*#__PURE__*/React.createElement(ReportPolarOptions, {
      cx: props.cx,
      cy: props.cy,
      startAngle: (_props$startAngle = props.startAngle) !== null && _props$startAngle !== void 0 ? _props$startAngle : defaultProps.startAngle,
      endAngle: (_props$endAngle = props.endAngle) !== null && _props$endAngle !== void 0 ? _props$endAngle : defaultProps.endAngle,
      innerRadius: innerRadius,
      outerRadius: outerRadius
    }), /*#__PURE__*/React.createElement(CategoricalChartWrapper, _extends({}, props, {
      ref: ref
    })));
  });

  // in recharts 2.x the returned component has the displayName of the chart itself
  // set that here so it isn't lost (until we know we don't need it anymore)
  CategoricalChart.displayName = CategoricalChartWrapper.displayName;
  return CategoricalChart;
};