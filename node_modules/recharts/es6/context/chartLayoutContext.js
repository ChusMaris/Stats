import React, { createContext, useContext, useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '../state/hooks';
import { setChartSize, setMargin } from '../state/layoutSlice';
import { selectChartOffset, selectChartViewBox } from '../state/selectors/selectChartOffset';
import { selectChartHeight, selectChartWidth } from '../state/selectors/containerSelectors';
import { useIsPanorama } from './PanoramaContext';
import { selectBrushDimensions, selectBrushSettings } from '../state/selectors/brushSelectors';
export var ClipPathIdContext = /*#__PURE__*/createContext(undefined);
// is the updateId necessary? Can we do without? Perhaps hook dependencies are better than explicit updateId.
var UpdateIdContext = /*#__PURE__*/createContext(0);
/**
 * Will add all the properties required to render all individual Recharts components into a React Context.
 *
 * If you want to read these properties, see the collection of hooks exported from this file.
 *
 * @param {object} props CategoricalChartState, plus children
 * @returns React Context Provider
 */
export var ChartLayoutContextProvider = props => {
  var {
    updateId,
    clipPathId,
    children
  } = props;

  /*
   * This pretends to be a single context but actually is split into multiple smaller ones.
   * Why?
   * Because one React Context only allows to set one value.
   * But we need to set multiple values.
   * If we do that with one context, then we force re-render on components that might not even be interested
   * in the part of the state that has changed.
   *
   * By splitting into smaller contexts, we allow each component to be optimized and only re-render when its dependencies change.
   *
   * To actually achieve the optimal re-render, it is necessary to use React.memo().
   * See the test file for details.
   */
  return /*#__PURE__*/React.createElement(UpdateIdContext.Provider, {
    value: updateId
  }, /*#__PURE__*/React.createElement(ClipPathIdContext.Provider, {
    value: clipPathId
  }, children));
};
export var useClipPathId = () => {
  return useContext(ClipPathIdContext);
};
export var useViewBox = () => {
  var _useAppSelector;
  var panorama = useIsPanorama();
  var rootViewBox = useAppSelector(selectChartViewBox);
  var brushDimensions = useAppSelector(selectBrushDimensions);
  var brushPadding = (_useAppSelector = useAppSelector(selectBrushSettings)) === null || _useAppSelector === void 0 ? void 0 : _useAppSelector.padding;
  if (!panorama) {
    return rootViewBox;
  }
  return {
    width: brushDimensions.width - brushPadding.left - brushPadding.right,
    height: brushDimensions.height - brushPadding.top - brushPadding.bottom,
    x: brushPadding.left,
    y: brushPadding.top
  };
};
var manyComponentsThrowErrorsIfOffsetIsUndefined = {};
export var useOffset = () => {
  var _useAppSelector2;
  return (_useAppSelector2 = useAppSelector(selectChartOffset)) !== null && _useAppSelector2 !== void 0 ? _useAppSelector2 : manyComponentsThrowErrorsIfOffsetIsUndefined;
};
export var useChartWidth = () => {
  return useAppSelector(selectChartWidth);
};
export var useChartHeight = () => {
  return useAppSelector(selectChartHeight);
};
var manyComponentsThrowErrorsIfMarginIsUndefined = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
export var useMargin = () => {
  var _useAppSelector3;
  return (_useAppSelector3 = useAppSelector(state => state.layout.margin)) !== null && _useAppSelector3 !== void 0 ? _useAppSelector3 : manyComponentsThrowErrorsIfMarginIsUndefined;
};
export var useUpdateId = () => "brush-".concat(useContext(UpdateIdContext));
export var selectChartLayout = state => state.layout.layoutType;
export var useChartLayout = () => useAppSelector(selectChartLayout);
export var ReportChartSize = props => {
  var dispatch = useAppDispatch();
  useEffect(() => {
    dispatch(setChartSize(props));
  }, [dispatch, props]);
  return null;
};
export var ReportChartMargin = _ref => {
  var {
    margin
  } = _ref;
  var dispatch = useAppDispatch();
  useEffect(() => {
    dispatch(setMargin(margin));
  }, [dispatch, margin]);
  return null;
};